## 强缓存与协商缓存

1. 发起请求时，会根据请求头部信息去浏览器缓存中检查是否命中强缓存，如果命中则直接返回浏览器缓存，不发请求给服务器
2. 如果没有命中强缓存，则向服务器发送请求，服务器根据响应头的 `cache-control` 及 `expires` 来判断浏览器本地缓存是否过期。如果没过期，返回状态码304，使用缓存，称之为缓存协商；如果过期了，服务器将返回完整的资源信息，浏览器加载新的资源，并更新本地缓存



## 缓存位置

`Service Worker`

​	运行在浏览器背后的独立线程，一般可以用来实现离线缓存的功能

​	在浏览器的 `application` 的 `cache tab` 下的 `cache storage` 中可以查看所有的缓存

`Memory Cache`

​	放在内存中，主要包含的是当前页面中已经下载的资源，关闭页面后，内存释放

`Disk Cache`

​	硬盘，一般大文件会放在硬盘中缓存

`Push Cache`

​	以上三者皆未命中的情况下，才会在 ` Push cache ` 中缓存

​	它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂

优先级顺序：`Service Worker`  > ` Memory Cache`  >  `Disk Cache`  >  `Push Cache` 



## 强缓存 - Cache-control 和 Expires

这两个都是用来表示资源在浏览器缓存的有效期，放在请求的 `http` 头部信息中，是 **强缓存** 的判断依据

`expires` 是在 `http1.0` 中提出，是服务器返回的是一个绝对时间，但如果客户端修改了本地时间，就能影响判断，所以在 `http1.1` 中提出了  `cache-control`

`cache-control` 是服务器返回的是一个相对时间，可以由多个字段组合而成，主要又以下几个值：

- `max-age` : 值是一个时间长度，单位是s，在这个时间段内缓存是有效的
- `public` : 表示响应内容可以被任何对象（客户端、代理服务器...）缓存
- `private` : 只有发起请求的浏览器才可以进行缓存
- `s-maxage` : 与 `max-age` 一样，但是只会在代理服务器中生效
- `no-cache` : 每次发请求前，强制向服务器验证，如果服务器允许，才可以使用本地缓存
- `no-store` : 真正意义上的禁止缓存，每次请求都要向服务器重新获取数据



## 缓存协商 - Last-modified 和 if-Modified-Since

**缓存协商** 主要是利用 `Last-Modified，If-Modified-Since` 和 `ETag、If-None-Match` 这两对来判断的的。

`Last-Modified`表示该资源在服务器上的最后修改时间，该字段是在浏览器第一次向服务器请求该资源时，服务器返回的一个字段。

当浏览器再次向服务器请求这个资源时，会在request的header上加上`If-Modified-Since`的字段，这个字段的值就是上一次请求时返回的`Last-Modified`的值。

当服务器再次收到资源请求时，会根据请求头中的`If-Modified-Since`字段与资源在服务器上的最后修改时间进行对比，如果没有变化则返回`304 Not Modified`，否则就正常返回资源内容。

其实这个方法也是会有缺陷的，例如服务器端有个修改非常频繁的文件，可能就会出现服务器上资源发生了变化，但是最后修改时间却没有变化，这个时候缓存命中就会出现问题了，所以就衍生出了另一对`ETag、If-None-Match`来管理缓存协商

`ETag、If-None-Match`返回的是一个校验码。`ETag`可以保证每一个资源都是唯一的，资源发生变化都会导致`ETag`变化，服务器则根据浏览器发送的`If-None-Match`字段值来判断是否命中缓存，其中`If-None-Match`的值就是浏览器第一次请求该资源时，服务器返回的`ETag`值，这样就很好的解决了上述`Last-Modified`遇到的问题。

## 注意

**缓存协商** 必须配合 **强缓存** 的使用，如果不启用 **强缓存** ，**缓存协商** 就根本没有意义。

​																			