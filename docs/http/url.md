# 从浏览器地址输入url到显示页面的步骤



## 简略版

1. 浏览器根据用户输入的 `URL` ，交给 `DNS` 解析，查到真正的 `IP` 地址，向服务器发起请求。
2. 服务器处理完之后，返回数据，浏览器会收到文件数据，如`html`，`css`，`js`，图像等等。
3. 浏览器对下载到的资源进行解析，建立相应的内部数据结构；载入解析到得资源文件，渲染页面，完成显示页面效果。



## 详细版

  大概可以分为几个步骤：

  1. 解析`URL`
  2. 查询强缓存 (命中则返回)
  3. `DNS`域名解析 (递归查询，迭代查询)
  4. `TCP`/`IP`三次握手
  5. 发起`HTTP`请求
  6. 查询协商缓存
  7. 服务器接受请求并返回`HTTP`报文
  8. 浏览器渲染页面
  9. 断开连接，`TCP`四次挥手

### 详解

1. 解析`URL`，解析出协议、主机、端口、路径、查询参数、锚点，并构造一个`http`请求。

2. 浏览器根据请求头中的`expires(http1.0)`和`cache-control(http1.1)`判断是否命中强缓存，如果命中了，直接返回。

3. 将`URL`解析成`IP`地址，浏览器会根据`URL`去**浏览器缓存**中寻找该`URL`的`IP`；没有的话去**系统缓存**中找，还是没有的话去**路由器缓存**中寻找；再没有就去**系统host文件**中找。前面一部分我们称为**递归查询**。如果依旧没有，那最后只能去请求 `DNS`**服务器**，但是局部的DNS服务器并不会自己向其他服务器进行查询，而是把能够解析该域名的服务器`IP`地址返回给客户端，客户端会不断的向这些服务器进行查询，直到查询到了位置，这部分称为**迭代查询**。
   
4. 发送请求前，客户端会和服务端之间建立连接 `TCP connection`(由客户端发起)。
    > 第一次握手：客户端向服务端发送SYN包，告知服务端，客户端要发请求了。<br>第二次握手：服务端向客户端发送ACK+SYN包，告诉客户端，我准备好了，你来吧。<br>第三次握手：客户端向服务端发送ACK包，告诉服务端，我收到你的消息了，准备发送。

5. 浏览器携带缓存标识向服务器发送`HTTP`请求。
   
6. 服务器根据请求头中的 `if-None-Match` 或者 `If-Modified-Since` 来与 `Etag` 或者 `Last-Modified` 进行比较，最终决定是否使用协商缓存
    > 浏览器第一次给服务器发送请求后，服务器会在响应头中加上 `Last-Modified` 或者 `Etag`，在下次浏览器请求时，会在请求头中加到对应的字段 `If-Modified-Since` 或者 `if-None-Match` 中去。<br>其中，`Last-Modified` 和 `If-Modified-Since` 是一对，`Etag` 和 `if-None-Match` 是一对。由于 `Last-Modified` 和 `If-Modified-Since` 比较的是最后的修改时间是否有差异，而如果在本地打开缓存文件会导致最后更新时间被被修改，与服务器的最后修改时间不一致，所以在HTTP1.1中出现了 `Etag` 和 `if-None-Match`，其中 `Etag` 是服务器根据文件内容，生成的唯一标识，一旦文件内容有改动，这个标识就会改变。<br>**注意**：如果两种方式都支持的话，服务器会优先考虑 `ETag`。

7. 服务器处理完之后，返回数据，浏览器会收到文件数据，如`html`，`css`，`js`，图像等等。

8. 浏览器根据 `html` 文件生成 `dom` 树，根据 `css` 文件生成 `cssom` 树，然后合并这两棵树生成渲染树，然后渲染页面并且展示。要注意的是，当浏览器解析 `html` 文件时候如果遇到了内联或者外联的 `js` 代码，会暂停 `dom` 树的生成，等 `js` 代码执行完成之后，才能继续生成树并渲染。

9. 此时，客户端和服务端都处于established状态，
    > 第一次挥手：客户端发送FIN包给服务端，提出想要断开连接。<br>第二次挥手：服务端接收到FIN包后，向客户端发送ACK包，表明已经收到客户端的消息。<br>第三次挥手：服务端也想要断开连接时，会像第一次挥手时一样，发送FIN包给客户端。<br>第四次挥手：客户端向服务端发送ACK包，表示收到断开请求。

    > 在第四次挥手后，服务端收到ACK包，就会关闭连接。而客户端则会等待2MSL (最大报文生存时间)，确保服务端收到消息。
    
    > **为什么是2MSL？** <br> 因为网络并不总是可靠的，有可能最后的ACK包丢失了，所以，第1个MSL用来确保ACK包能到达对端，而第2个MSL用来确保对端因没收到ACK包而重发的FIN包能到达。

    > **为什么要四次挥手？**<br>当客户端请求断开连接时，服务端只能先返回ACK包，它需要等服务端所有的报文发送完了，才能发送FIN包。所以会比三次握手要多一次。




   



